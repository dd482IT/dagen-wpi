# Generate SQL/JSON Queries and Matching Types

## Fetch nested data spanning any number of related tables via a single query

This tool is intended to be run at build time to generate SQL/JSON queries from
specifications (yaml) you provide describing the tables and fields from which to
fetch data. 

## No runtime library necessary (other than what you probably already have)

The queries are generated as plain SQL text, which can be included in an
application as static resources and executed directly in the DMBS via plain
JDBC, etc, with no extra library needed at run-time. 

## Result type generation

Types can be generated for each query which match the results precisely,
including only the fields actually selected in each part of the query, and their
nullability as derived from database metadata. The query results can be directly
serialized to the top result type using common libraries, such as Jackson in 
Java.


## Find errors in queries or code using result types at build time

The database metadata, which is generated by the tool, also allows validation of
table name, field names, and the table relationships referenced in a query
specification. This gives a high degree of confidence that the queries and types
generated are consistent with the state of the database structure, with failures
indicated at build time. An additional level of safety is afforded by accessing
query results only via the auto-generated result types which are guaranteed to
match the actual query results.

## Parameter safety

Both queries and modification statements can be parameterized. For common cases
that parameters found in the statements are bound to specific fields via common
operator comparisons, they are declared in source code as constants. This makes
them easier to use without error and allows flagging mistakes caused by database
changes that would affect the parameters at compile time.


## Workflow

1) Generate database metadata, stored in a json or yaml file. This should be
done whenever the database has changes that should be incorporated.
2) Create a queries specification file, describing for each query a starting or
"top" table, its fields to be included, any parent and child tables of
the top table, fields and parent and child tables of those parent and child
tables, and so on to any depth.  
3) Run the tool specifying the above two files and the output directories for
the generated SQL and source code files. This step can be run as part of the
application build process.
4) At application run time, load the SQL resource file for a query, submit to
the database, specifying any embedded parameter values, and deserialize results
to the generated top level type for the query.

## Why not just use joins to pull data from related tables?

If we limit ourselves to "rectangular" results of rows and columns of simple
types, which most database access libraries do, then joins seem to be the
solution to the problem of pulling related data from multiple tables in a single
query. However joins are not the right tool for fetching data for the important
case that data from *independent child tables* of a parent table are needed in
a query. In this case joins suffer from a combinatorial explosion in the number
of result rows, yielding the product of the number of child rows involved
whereas ideally they would only contribute their sum (at most) to the results.
Likewise the join approach would produce a large amount of duplicated data which
would have to be "de-convolved" in the receiving client from the combinations
introduced by the cartesion product operation. Definitely using joins for such
a case would be inefficient, tedious, and error-prone.

## Example
![Example schema diagram](images/DrugsSchema.png)

TODO: diagram showing independent child tables
 N1 + N2 + N3 results for SQL/JSON
 N1 * N2 * N3 from a join.


