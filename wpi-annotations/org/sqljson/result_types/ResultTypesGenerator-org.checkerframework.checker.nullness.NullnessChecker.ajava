package org.sqljson.result_types;

import java.util.*;
import java.util.function.Function;
import static java.util.Collections.emptyMap;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.*;
import static java.util.function.Function.identity;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.sqljson.util.StringFuns;
import org.sqljson.dbmd.*;
import org.sqljson.query_specs.*;
import static org.sqljson.util.Nullables.*;

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.nullness.NullnessChecker")
public class ResultTypesGenerator {

    private final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull DatabaseMetadata dbmd;

    private final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.MonotonicNonNull String defaultSchema;

    private final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Function<String, String> defaultPropertyNameFn;

    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    public ResultTypesGenerator(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull DatabaseMetadata dbmd, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.Nullable String defaultSchema, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Function<String, String> defaultPropertyNameFn) {
        this.dbmd = dbmd;
        this.defaultSchema = defaultSchema;
        this.defaultPropertyNameFn = defaultPropertyNameFn;
    }

    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    public @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ResultType> generateResultTypes(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull TableJsonSpec tjs) {
        return this.generateResultTypesWithTypesInScope(tjs, emptyMap());
    }

    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    private @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ResultType> generateResultTypesWithTypesInScope(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull TableJsonSpec tjs, // types by type name
    @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Map<String, ResultType> envTypesInScope) {
        Map<String, ResultType> typesInScope = new HashMap<>(envTypesInScope);
        var typeBuilder = new ResultTypeBuilder();
        var resultTypes = new ArrayList<ResultType>();
        RelId relId = dbmd.toRelId(tjs.getTable(), defaultSchema);
        // Add the table's own fields and expressions involving those fields.
        typeBuilder.addSimpleTableFieldProperties(getSimpleTableFieldProperties(relId, tjs.getFieldExpressionsList()));
        typeBuilder.addTableExpressionProperties(getTableExpressionProperties(relId, tjs.getFieldExpressionsList()));
        // Inline parents can contribute fields to any primary field category (table field,
        // expression, parent ref, child collection). Get the inline parent fields, and the result
        // types from the tables themselves and recursively from their specified related tables.
        var inlineParentsContr = getInlineParentContrs(relId, tjs.getInlineParentTablesList(), typesInScope);
        typeBuilder.addAllFieldsFrom(inlineParentsContr.typeBuilder);
        resultTypes.addAll(inlineParentsContr.resultTypes);
        inlineParentsContr.resultTypes.forEach(t -> typesInScope.put(t.getTypeName(), t));
        // Get referenced parent fields and result types, with result types from related tables.
        var refdParentsContr = getRefdParentContrs(relId, tjs.getReferencedParentTablesList(), typesInScope);
        typeBuilder.addParentReferenceProperties(refdParentsContr.parentReferenceProperties);
        resultTypes.addAll(refdParentsContr.resultTypes);
        refdParentsContr.resultTypes.forEach(t -> typesInScope.put(t.getTypeName(), t));
        // Get the child collection fields and result types, with result types from related tables.
        var childCollsContr = getChildCollectionContrs(tjs.getChildTableCollectionsList(), typesInScope);
        typeBuilder.addChildCollectionProperties(childCollsContr.childCollectionProperties);
        resultTypes.addAll(childCollsContr.resultTypes);
        childCollsContr.resultTypes.forEach(t -> typesInScope.put(t.getTypeName(), t));
        // The top table's type must be added at leading position in the returned list.
        // If the type is identical to one already in scope when ignoring only any name
        // extension added to make the name unique, then add the previously generated
        // instance instead.
        // Base type name is the desired name, without any trailing digits.
        String baseTypeName = StringFuns.upperCamelCase(tjs.getTable());
        ResultType bnResType = typeBuilder.build(baseTypeName);
        if (// No previously generated type of same base name.
        !typesInScope.containsKey(baseTypeName))
            resultTypes.add(0, bnResType);
        else {
            // Search the previous scope (prior to this type-building) for a type which is identical
            // except for any additions to the name to make it unique. Note: Only the original
            // scope (prior to this type building) is searched because the additions made here
            // to typesInScope are proper parts of the type and so not identical to the whole type.
            ResultType existingIdenticalType = findTypeIgnoringNameExtensions(bnResType, envTypesInScope);
            if (// Identical previously generated type found, use it as top type.
            existingIdenticalType != null)
                resultTypes.add(0, existingIdenticalType);
            else // This type does not match any previously generated, but needs a new name.
            {
                String uniqueName = StringFuns.makeNameNotInSet(baseTypeName, typesInScope.keySet(), "_");
                resultTypes.add(0, bnResType.withTypeName(uniqueName));
            }
        }
        return resultTypes;
    }

    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    private @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<SimpleTableFieldProperty> getSimpleTableFieldProperties(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull RelId relId, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<TableFieldExpr> tableFieldExpressions) {
        var fields = new ArrayList<SimpleTableFieldProperty>();
        Map<String, Field> dbFieldsByName = getTableFieldsByName(relId);
        for (TableFieldExpr tfe : tableFieldExpressions) {
            if (tfe.getField() != null) {
                Field dbField = requireNonNull(dbFieldsByName.get(dbmd.normalizeName(requireNonNull(tfe.getField()))), "no metadata for field " + relId + "." + tfe.getField());
                fields.add(new SimpleTableFieldProperty(getOutputFieldName(tfe, dbField), dbField, tfe.getFieldTypeInGeneratedSource()));
            }
        }
        return fields;
    }

    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    private @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<TableExpressionProperty> getTableExpressionProperties(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull RelId relId, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<TableFieldExpr> tableFieldExpressions) {
        var fields = new ArrayList<TableExpressionProperty>();
        for (TableFieldExpr tfe : tableFieldExpressions) {
            if (tfe.getExpression() != null) {
                String jsonProperty = valueOrThrow(tfe.getJsonProperty(), () -> new RuntimeException("Expression field " + relId + "." + tfe + " requires a json property."));
                fields.add(new TableExpressionProperty(jsonProperty, tfe.getExpression(), tfe.getFieldTypeInGeneratedSource()));
            }
        }
        return fields;
    }

    /// Get the inline parent contributions of properties and result types for the type to be generated.
    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    private @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull InlineParentContrs getInlineParentContrs(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull RelId relId, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ParentSpec> inlineParentSpecs, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Map<String, ResultType> envTypesInScope) {
        var typeBuilder = new ResultTypeBuilder();
        var resultTypes = new ArrayList<ResultType>();
        var typesInScope = new HashMap<>(envTypesInScope);
        for (var parentSpec : inlineParentSpecs) {
            // Generate types for the parent table and any related tables it includes recursively.
            List<ResultType> parentResultTypes = generateResultTypesWithTypesInScope(parentSpec.getParentTableJsonSpec(), typesInScope);
            // will not be generated
            ResultType parentType = parentResultTypes.get(0);
            // If the parent record might be absent, then all inline fields must be nullable.
            boolean forceNullable = parentSpec.getParentTableJsonSpec().hasCondition() || !someFkFieldKnownNotNullable(parentSpec, relId);
            typeBuilder.addAllFieldsFrom(parentType, forceNullable);
            var actuallyGeneratedParentTypes = parentResultTypes.subList(1, parentResultTypes.size());
            resultTypes.addAll(actuallyGeneratedParentTypes);
            actuallyGeneratedParentTypes.forEach(t -> typesInScope.put(t.getTypeName(), t));
        }
        return new InlineParentContrs(typeBuilder, resultTypes);
    }

    /// Get fields and types from the given referenced parents.
    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    private @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull RefdParentContrs getRefdParentContrs(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull RelId relId, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ParentSpec> referencedParentSpecs, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Map<String, ResultType> envTypesInScope) {
        var parentRefFields = new ArrayList<ParentReferenceProperty>();
        var resultTypes = new ArrayList<ResultType>();
        var typesInScope = new HashMap<>(envTypesInScope);
        for (var parentSpec : referencedParentSpecs) {
            String refName = requireNonNull(parentSpec.getReferenceName());
            // Generate types by traversing the parent table and its parents and children.
            List<ResultType> parentResultTypes = generateResultTypesWithTypesInScope(parentSpec.getParentTableJsonSpec(), typesInScope);
            ResultType parentType = parentResultTypes.get(0);
            boolean forceNullable = parentSpec.getParentTableJsonSpec().hasCondition() || !someFkFieldKnownNotNullable(parentSpec, relId);
            parentRefFields.add(new ParentReferenceProperty(refName, parentType, forceNullable));
            resultTypes.addAll(parentResultTypes);
            parentResultTypes.forEach(t -> typesInScope.put(t.getTypeName(), t));
        }
        return new RefdParentContrs(parentRefFields, resultTypes);
    }

    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    private @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull ChildCollectionContrs getChildCollectionContrs(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ChildCollectionSpec> childCollectionSpecs, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Map<String, ResultType> envTypesInScope) {
        var childCollectionProperties = new ArrayList<ChildCollectionProperty>();
        var resultTypes = new ArrayList<ResultType>();
        var typesInScope = new HashMap<>(envTypesInScope);
        for (var childCollSpec : childCollectionSpecs) {
            // Generate types by traversing the child table and its parents and children recursively.
            List<ResultType> childResultTypes = generateResultTypesWithTypesInScope(childCollSpec.getTableJson(), typesInScope);
            // Mark the top-level child type as unwrapped if specified.
            ResultType childType = childResultTypes.get(0).withUnwrapped(valueOr(childCollSpec.getUnwrap(), false));
            childResultTypes.set(0, childType);
            childCollectionProperties.add(new ChildCollectionProperty(childCollSpec.getCollectionName(), childType, false));
            resultTypes.addAll(childResultTypes);
            childResultTypes.forEach(t -> typesInScope.put(t.getTypeName(), t));
        }
        return new ChildCollectionContrs(childCollectionProperties, resultTypes);
    }

    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    private @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull String getOutputFieldName(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull TableFieldExpr tableFieldExpr, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Field dbField) {
        return valueOrGet(tableFieldExpr.getJsonProperty(), () -> defaultPropertyNameFn.apply(dbField.getName()));
    }

    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    private @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Map<String, Field> getTableFieldsByName(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull RelId relId) {
        RelMetadata relMd = valueOrThrow(dbmd.getRelationMetadata(relId), () -> new RuntimeException("Metadata for table " + relId + " not found."));
        return relMd.getFields().stream().collect(toMap(Field::getName, identity()));
    }

    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.dataflow.qual.SideEffectFree
    private @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.Nullable ResultType findTypeIgnoringNameExtensions(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull ResultType typeToFind, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Map<String, ResultType> inMap) {
        String baseName = typeToFind.getTypeName();
        for (var entry : inMap.entrySet()) {
            boolean baseNamesMatch = entry.getKey().startsWith(baseName) && (entry.getKey().equals(baseName) || // underscore used as suffix separator for making unique names
            entry.getKey().charAt(baseName.length()) == '_');
            if (baseNamesMatch && typeToFind.equalsIgnoringName(entry.getValue()))
                return entry.getValue();
        }
        return null;
    }

    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.defaultSchema" }, qualifier = org.checkerframework.checker.nullness.qual.Nullable.class)
    private  @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull boolean someFkFieldKnownNotNullable(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull ParentSpec parentSpec, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull RelId childRelId) {
        RelId parentRelId = dbmd.toRelId(parentSpec.getParentTableJsonSpec().getTable(), defaultSchema);
        Set<String> specFkFields = parentSpec.getChildForeignKeyFieldsSet();
        ForeignKey fk = valueOrThrow(dbmd.getForeignKeyFromTo(childRelId, parentRelId, specFkFields, ForeignKeyScope.REGISTERED_TABLES_ONLY), () -> new RuntimeException("foreign key to parent not found"));
        Map<String, Field> childFieldsByName = getTableFieldsByName(childRelId);
        for (String fkFieldName : fk.getChildFieldNames()) {
            Field fkField = valueOrThrow(childFieldsByName.get(fkFieldName), () -> new RuntimeException("foreign key not found"));
            if (!valueOr(fkField.getNullable(), true))
                return true;
        }
        return false;
    }
}

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.nullness.NullnessChecker")
class InlineParentContrs {

    @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull ResultTypeBuilder typeBuilder;

    @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ResultType> resultTypes;

    InlineParentContrs(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull ResultTypeBuilder typeBuilder, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ResultType> resultTypes) {
        this.typeBuilder = typeBuilder;
        this.resultTypes = resultTypes;
    }
}

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.nullness.NullnessChecker")
class RefdParentContrs {

    @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ParentReferenceProperty> parentReferenceProperties;

    @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ResultType> resultTypes;

    RefdParentContrs(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ParentReferenceProperty> parentReferenceProperties, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ResultType> resultTypes) {
        this.parentReferenceProperties = parentReferenceProperties;
        this.resultTypes = resultTypes;
    }
}

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.nullness.NullnessChecker")
class ChildCollectionContrs {

    @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ChildCollectionProperty> childCollectionProperties;

    @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ResultType> resultTypes;

    ChildCollectionContrs(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ChildCollectionProperty> childCollectionProperties, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull List<ResultType> resultTypes) {
        this.childCollectionProperties = childCollectionProperties;
        this.resultTypes = resultTypes;
    }
}
